<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Language and Grammar - Theory of Computation</title>
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <header>
        <div class="container">
            <h1><a href="../index.html" style="color: white; text-decoration: none;">Learn Theory of Computation</a></h1>
            <nav>
                <ul>
                    <li><a href="../index.html">Home</a></li>
                    <li><a href="../index.html#chapters">Chapters</a></li>
                    <li><a href="../index.html#learning-path">Learning Path</a></li>
                    <li><a href="../index.html#visualizer">3D Visualizer</a></li>
                </ul>
            </nav>
            <div class="header-controls">
                <button id="theme-toggle" class="theme-toggle">
                    <i class="fas fa-moon"></i>
                    <span>Dark Mode</span>
                </button>
            </div>
        </div>
    </header>

    <main class="topic-content">
        <section class="container">
            <h1>Language and Grammar</h1>
            
            <div class="content-layout">
                <div class="content-panel">
                    <div class="topic-section">
                        <h2>Definition</h2>
                        <p>In theoretical computer science and formal language theory, a language is a set of strings (sequences of symbols) over an alphabet. A grammar is a set of rules that define how to generate strings in a language.</p>
                        
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Alphabet (Σ)</strong>: A finite set of symbols</li>
                            <li><strong>String</strong>: A finite sequence of symbols from an alphabet</li>
                            <li><strong>Language</strong>: A set of strings over an alphabet</li>
                            <li><strong>Grammar</strong>: A set of rules for generating strings in a language</li>
                        </ul>
                    </div>

                    <div class="topic-section">
                        <h2>Types of Grammars</h2>
                        <p>Grammars are classified into four types according to the Chomsky hierarchy:</p>
                        
                        <div class="grammar-types">
                            <div class="grammar-type">
                                <h3>Type 0: Unrestricted Grammar</h3>
                                <ul>
                                    <li>Most general form of grammar</li>
                                    <li>Production rules have form α → β where α, β are strings of terminals and non-terminals</li>
                                    <li>α must contain at least one non-terminal</li>
                                    <li>Recognized by Turing Machines</li>
                                </ul>
                            </div>
                            
                            <div class="grammar-type">
                                <h3>Type 1: Context-Sensitive Grammar</h3>
                                <ul>
                                    <li>Production rules have form αAβ → αγβ</li>
                                    <li>Where A is a non-terminal, α, β, γ are strings of terminals/non-terminals</li>
                                    <li>γ must be non-empty</li>
                                    <li>Recognized by Linear Bounded Automata</li>
                                </ul>
                            </div>
                            
                            <div class="grammar-type">
                                <h3>Type 2: Context-Free Grammar</h3>
                                <ul>
                                    <li>Production rules have form A → γ</li>
                                    <li>Where A is a non-terminal, γ is a string of terminals/non-terminals</li>
                                    <li>Recognized by Pushdown Automata</li>
                                    <li>Used in programming language design</li>
                                </ul>
                            </div>
                            
                            <div class="grammar-type">
                                <h3>Type 3: Regular Grammar</h3>
                                <ul>
                                    <li>Production rules are of the form:
                                        <ul>
                                            <li>Right linear: A → aB or A → a</li>
                                            <li>Left linear: A → Ba or A → a</li>
                                        </ul>
                                    </li>
                                    <li>Where A, B are non-terminals, a is a terminal</li>
                                    <li>Recognized by Finite State Automata</li>
                                    <li>Used in lexical analysis</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="topic-section">
                        <h2>Chomsky Hierarchy</h2>
                        <p>The Chomsky hierarchy is a containment hierarchy of classes of formal grammars:</p>
                        <div class="hierarchy">
                            <div class="hierarchy-level level-0">
                                <h3>Type 0: Recursively Enumerable Languages</h3>
                            </div>
                            <div class="hierarchy-level level-1">
                                <h3>Type 1: Context-Sensitive Languages</h3>
                            </div>
                            <div class="hierarchy-level level-2">
                                <h3>Type 2: Context-Free Languages</h3>
                            </div>
                            <div class="hierarchy-level level-3">
                                <h3>Type 3: Regular Languages</h3>
                            </div>
                        </div>
                        <p>Each level is a proper subset of the level above it.</p>
                    </div>

                    <div class="topic-section">
                        <h2>Real-World Analogies</h2>
                        <div class="analogy">
                            <h3>Human Languages</h3>
                            <p>Just as human languages have grammar rules that determine valid sentences, formal languages have grammars that determine valid strings. For example, in English, "The cat sat on the mat" is grammatically correct while "Cat the mat on sat" is not.</p>
                        </div>
                        
                        <div class="analogy">
                            <h3>Programming Languages</h3>
                            <p>Programming languages like Python or Java have strict grammars that determine valid code. Syntax errors occur when code violates these grammatical rules.</p>
                        </div>
                        
                        <div class="analogy">
                            <h3>Musical Notation</h3>
                            <p>Musical notation has its own grammar - certain combinations of notes, rests, and symbols are valid while others are not. Sheet music that violates these rules would be unplayable.</p>
                        </div>
                    </div>

                    <div class="topic-section">
                        <h2>When and Why to Use in Computation</h2>
                        <ul>
                            <li><strong>Compiler Design</strong>: Grammars define the syntax of programming languages</li>
                            <li><strong>Natural Language Processing</strong>: Understanding and generating human language</li>
                            <li><strong>Data Validation</strong>: Ensuring data conforms to specific formats (e.g., email addresses, phone numbers)</li>
                            <li><strong>Protocol Design</strong>: Defining communication protocols in networks</li>
                            <li><strong>Pattern Recognition</strong>: Identifying patterns in strings of data</li>
                        </ul>
                    </div>

                    <div class="topic-section">
                        <h2>Academic Problem-Solving Tips</h2>
                        <ol>
                            <li><strong>Identify the Grammar Type</strong>: Determine if it's regular, context-free, etc.</li>
                            <li><strong>Check Production Rules</strong>: Verify that rules conform to the required format</li>
                            <li><strong>Generate Sample Strings</strong>: Try to derive strings to understand the language</li>
                            <li><strong>Use Parse Trees</strong>: Visualize derivations with tree structures</li>
                            <li><strong>Look for Patterns</strong>: Identify recurring structures in the grammar</li>
                        </ol>
                    </div>

                    <div class="topic-section">
                        <h2>Example Problems</h2>
                        <div class="problem">
                            <h3>Problem 1</h3>
                            <p>Given the grammar G = ({S}, {a, b}, P, S) where P = {S → aSb, S → ε}, what language does it generate?</p>
                            <div class="solution">
                                <h4>Solution:</h4>
                                <p>This grammar generates the language L = {a^n b^n | n ≥ 0}, which consists of strings with equal numbers of a's followed by b's.</p>
                                <p>Derivation example for n=3: S → aSb → aaSbb → aaaSbbb → aaabbb</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="visualization-container">
                    <div class="visualization-panel" id="visualization-container">
                        <h3>3D Grammar Visualization</h3>
                        <div class="visualization-placeholder" id="visualization-placeholder">
                            <i class="fas fa-cube fa-3x"></i>
                            <p>Interactive 3D visualization of grammar hierarchy</p>
                            <p class="instructions">Click and drag to rotate | Scroll to zoom</p>
                        </div>
                        <div class="visualization-controls">
                            <button class="control-btn" id="animate-btn"><i class="fas fa-play"></i> Animate Hierarchy</button>
                            <button class="control-btn" id="reset-view-btn"><i class="fas fa-redo"></i> Reset View</button>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2023 Learn Theory of Computation. All rights reserved.</p>
            <div class="footer-links">
                <a href="#">Privacy Policy</a>
                <a href="#">Terms of Service</a>
                <a href="#">Contact</a>
            </div>
        </div>
    </footer>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    
    <!-- Visualization Script -->
    <script src="../js/visualizations.js"></script>
    <script>
        // Initialize 3D visualization when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const visualizationContainer = document.getElementById('visualization-container');
            const visualizationPlaceholder = document.getElementById('visualization-placeholder');
            const animateBtn = document.getElementById('animate-btn');
            const resetViewBtn = document.getElementById('reset-view-btn');
            const themeToggle = document.getElementById('theme-toggle');
            
            // Theme toggle functionality
            let currentTheme = 'light';
            
            // Check for saved theme preference or respect OS preference
            const savedTheme = localStorage.getItem('toc-theme');
            const osPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            if (savedTheme) {
                currentTheme = savedTheme;
            } else if (osPrefersDark) {
                currentTheme = 'dark';
            }
            
            // Apply theme
            document.documentElement.setAttribute('data-theme', currentTheme);
            updateThemeToggle();
            
            // Toggle theme
            themeToggle.addEventListener('click', function() {
                currentTheme = currentTheme === 'light' ? 'dark' : 'light';
                document.documentElement.setAttribute('data-theme', currentTheme);
                localStorage.setItem('toc-theme', currentTheme);
                updateThemeToggle();
                
                // Add visual feedback
                themeToggle.classList.add('active');
                setTimeout(() => {
                    themeToggle.classList.remove('active');
                }, 300);
                
                // Show notification
                const themeText = currentTheme === 'light' ? 'Light' : 'Dark';
                showNotification(`${themeText} mode activated`);
            });
            
            // Function to update theme toggle button
            function updateThemeToggle() {
                const themeIcon = currentTheme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
                const themeText = currentTheme === 'light' ? 'Dark Mode' : 'Light Mode';
                themeToggle.innerHTML = `<i class="${themeIcon}"></i> <span>${themeText}</span>`;
            }
            
            let visualizer = null;
            
            // Initialize visualizer if container exists
            if (visualizationContainer) {
                // Wait a bit for Three.js to load
                setTimeout(() => {
                    if (typeof TOCVisualizer !== 'undefined') {
                        // Hide placeholder
                        if (visualizationPlaceholder) {
                            visualizationPlaceholder.style.display = 'none';
                        }
                        
                        // Initialize visualizer
                        visualizer = new TOCVisualizer(visualizationContainer);
                        
                        // Load grammar visualization
                        visualizer.loadVisualization('language-grammar');
                        
                        // Setup controls
                        if (animateBtn) {
                            animateBtn.addEventListener('click', function() {
                                if (visualizer) {
                                    // Animate the visualization
                                    showNotification('Animating Grammar Hierarchy');
                                    
                                    // Animate camera rotation
                                    animateVisualization();
                                } else {
                                    showNotification('Visualization not available');
                                }
                            });
                        }
                        
                        if (resetViewBtn) {
                            resetViewBtn.addEventListener('click', function() {
                                if (visualizer) {
                                    // Reset camera position
                                    if (visualizer.camera) {
                                        visualizer.camera.position.set(0, 0, 15);
                                        visualizer.camera.lookAt(0, 0, 0);
                                    }
                                    // Reset controls
                                    if (visualizer.controls) {
                                        visualizer.controls.reset();
                                    }
                                    showNotification('View reset');
                                }
                            });
                        }
                    }
                }, 100);
            }
            
            // Function to animate the visualization
            function animateVisualization() {
                if (!visualizer || !visualizer.camera) return;
                
                const startTime = Date.now();
                const duration = 5000; // 5 seconds
                const startX = visualizer.camera.position.x;
                const startY = visualizer.camera.position.y;
                const startZ = visualizer.camera.position.z;
                
                function rotate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Rotate camera around the scene
                    const angle = progress * Math.PI * 2;
                    visualizer.camera.position.x = Math.sin(angle) * 15;
                    visualizer.camera.position.z = Math.cos(angle) * 15;
                    visualizer.camera.lookAt(0, 0, 0);
                    
                    if (progress < 1) {
                        requestAnimationFrame(rotate);
                    }
                }
                
                rotate();
            }
            
            // Notification system
            function showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'viz-notification';
                notification.textContent = message;
                notification.style.cssText = `
                    position: absolute;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(255, 255, 255, 0.9);
                    color: #0a0a1a;
                    padding: 10px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
                    z-index: 100;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    pointer-events: none;
                    font-size: 14px;
                `;
                
                visualizationContainer.appendChild(notification);
                
                // Animate in
                setTimeout(() => {
                    notification.style.opacity = '1';
                }, 100);
                
                // Remove after delay
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 2000);
            }
        });
    </script>
</body>
</html>